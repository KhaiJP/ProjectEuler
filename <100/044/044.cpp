#include<iostream>
#include<time.h>
using namespace std;
using ll = int64_t;

ll upper_limit = 1e4, answer = 1e18;


// has_inverse finds if n:: Int can be generated by f:: Function.
// in other words, return the value of proposition "∃k ∈ N s.t. f(k) = n"
// note that f must be monotonically non-decreasing since this function works with binary search
bool has_inverse(ll n, ll (*f)(ll)){
  ll ok = 1e8, ng = 0;
  while(ok - ng > 1){
    ll mid = (ok + ng) / 2;
    if(f(mid) >= n) ok = mid;
    else            ng = mid;
  }

  return f(ok) == n; 
}


ll pentagonal_prod(ll n){ return n * (3*n - 1) / 2; }
bool is_pentagonal(ll n){ return has_inverse(n, pentagonal_prod); }


int main(){
  clock_t start = clock();
  for(ll k = 2; k < upper_limit; ++k)for(ll j = k-1; j > 0; --j){
    ll Pk = pentagonal_prod(k), Pj = pentagonal_prod(j);
    ll diff = Pk - Pj, sum = Pk + Pj;

    if(answer < diff) break;
    if(is_pentagonal(diff) && is_pentagonal(sum)){
      answer = min(answer, diff);
    }
  }

  clock_t end = clock();
  const double time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
  cout << time << " sec" <<endl;
  cout << answer << endl;
  return 0;
}