"""
has_inverse finds if n:: Int can be generated by f:: Function.
in other words, return the value of proposition "∃k ∈ N s.t. f(k) = n"
note that f must be monotonically non-decreasing since this function works with binary search
"""
function has_inverse(n:: Int, f:: Function):: Bool
  # sufficiently big number; note that not f(bigger) to exceed MAX(Int64)
  bigger:: Int = 10 ^ 8
  smaller:: Int = 0
  # binary search; f(smaller) < n ≤ f(bigger)
  while bigger - smaller > 1
    mid:: Int = (bigger + smaller) ÷ 2

    if n <= f(mid)
      bigger = mid
    else
      smaller = mid
    end
  end

  return f(bigger) == n
end

pentagonalProd(n:: Int):: Int = n * (3*n-1) ÷ 2
isPentagonal(n:: Int):: Bool  = has_inverse(n, pentagonalProd)


function solve(upper_limit:: Int):: Int
  answer:: Int = 10^18
  for k ∈ 2:upper_limit
    for j ∈ (k-1):-1:1
      Pk:: Int = pentagonalProd(k)
      Pj:: Int = pentagonalProd(j)
      Δ:: Int  = Pk - Pj
      Σ:: Int  = Pk + Pj
      if answer < Δ
        break
      end
      if Δ |> isPentagonal && Σ |> isPentagonal
        answer = min(answer, Δ)
        break
      end
    end
  end

  return answer
end


function main():: Nothing
  upper_limit:: Int = 10^4
  upper_limit |> solve |> println

  return nothing
end


@time main()